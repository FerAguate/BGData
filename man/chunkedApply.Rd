% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{chunkedApply}
\alias{chunkedApply}
\title{Reads Chunks of Data from a Memory-Mapped File into Memory and Applies a
Function on Each Row or Column of a Matrix in Parallel.}
\usage{
chunkedApply(X, MARGIN, FUN, i = seq_len(nrow(X)), j = seq_len(ncol(X)),
  bufferSize = 5000, nBuffers = NULL, nTasks = nCores,
  nCores = parallel::detectCores(), verbose = FALSE, ...)
}
\arguments{
\item{X}{A matrix-like object, typically \code{@geno} of a \linkS4class{BGData}
object.}

\item{MARGIN}{The subscripts which the function will be applied over. 1
indicates rows, 2 indicates columns.}

\item{FUN}{The function to be applied.}

\item{i}{Indicates which rows of \code{X} should be used. Can be integer,
boolean, or character. By default, all rows are used.}

\item{j}{Indicates which columns of \code{X} should be used. Can be integer,
boolean, or character. By default, all columns are used.}

\item{bufferSize}{The number of rows or columns of \code{X} that are brought into
RAM for processing. Overwrites \code{nBuffers}. If both parameters are \code{NULL},
all elements in \code{i} or \code{j} are used. Defaults to 5000.}

\item{nBuffers}{The number of partitions of the rows or columns of \code{X} that
are brought into RAM for processing. Is overwritten by \code{bufferSize}. If both
parameters are \code{NULL}, all elements in \code{i} or \code{j} are used.}

\item{nTasks}{The number of tasks the problem should be broken into to be
distributed among \code{nCores} cores. Defaults to \code{nCores}.}

\item{nCores}{The number of cores (passed to \code{\link[parallel:mclapply]{parallel::mclapply()}}).
Defaults to the number of cores as detected by \code{\link[parallel:detectCores]{parallel::detectCores()}}.}

\item{verbose}{Whether progress updates will be posted. Defaults to \code{FALSE}.}

\item{...}{Additional arguments to be passed to \code{\link[=parallelApply]{parallelApply()}}.}
}
\description{
Similar to \code{\link[base:apply]{base::apply()}}, but designed to bring chunks of data into memory
and carry out operations on them in parallel. \code{nBufferSize} rows or columns
of the input matrix \code{X} are read into memory and handed over to
\code{\link[=parallelApply]{parallelApply()}}. This function is only useful for memory-mapped files. For
data that is already in memory, use \code{\link[=parallelApply]{parallelApply()}} directly.
}
\details{
\code{bufferSize} and \code{nTasks} have to be chosen carefully to avoid running out
of memory. As a rule of thumb, at least around \code{object_size(buffer) +
(nCores * (object_size(buffer) / nTasks)) + object_size(result)} MB of total
memory will be needed, not including potential copies of your data that
might be created (for example \code{\link[stats:lsfit]{stats::lsfit()}} runs \code{cbind(1, X)}).
Therefore, for 20 nodes and 20 tasks you will need at least \code{2 * object_size(buffer)} MB, for 20 nodes and 40 tasks \code{1.5 * object_size(buffer)} MB, etc.
}
\seealso{
\code{\link[=parallelApply]{parallelApply()}} if \code{X} is not a memory-mapped matrix or can be
held in memory.
}
