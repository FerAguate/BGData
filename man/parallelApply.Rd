% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{parallelApply}
\alias{parallelApply}
\title{Applies a Function on Each Row or Column of a Matrix in Parallel.}
\usage{
parallelApply(X, MARGIN, FUN, nTasks = nCores,
  nCores = getOption("mc.cores", 2L), ...)
}
\arguments{
\item{X}{A matrix or matrix-like object.}

\item{MARGIN}{The subscripts which the function will be applied over. \code{1}
indicates rows, \code{2} indicates columns.}

\item{FUN}{The function to be applied.}

\item{nTasks}{The number of tasks the problem should be broken into to be
distributed among \code{nCores} cores. Defaults to \code{nCores}.}

\item{nCores}{The number of cores (passed to \code{\link[parallel:mclapply]{parallel::mclapply()}}).
Defaults to the number of cores as detected by \code{\link[parallel:detectCores]{parallel::detectCores()}}.}

\item{...}{Additional arguments to be passed to \code{\link[base:apply]{base::apply()}}.}
}
\description{
Similar to \code{\link[base:apply]{base::apply()}}, but designed to carry out operations in
parallel.  The input matrix \code{X} is broken into \code{nTasks} chunks and passed to
\code{\link[parallel:mclapply]{parallel::mclapply()}} which applies \code{FUN} on either the rows or the columns
of each chunk.
}
\details{
\code{nTasks} has to be chosen carefully to avoid running out of memory. As a
rule of thumb, at least around \code{object_size(X) + (nCores *
(object_size(X) / nTasks)) + object_size(result)} MB of total memory will be
needed, not including potential copies of your data that might be created
(for example \code{\link[stats:lsfit]{stats::lsfit()}} runs \code{cbind(1, X)}). Therefore, for 20 nodes
and 20 tasks you will need at least \code{2 * object_size(X)} MB, for 20 nodes
and 40 tasks \code{1.5 * object_size(X)} MB, etc.

If \code{nTasks} is \code{1}, \code{\link[base:apply]{base::apply()}} will be called directly without
parallelism.
}
\examples{
# Load example data
bg <- BGData:::loadExample()

# Compute standard deviation of columns
parallelApply(X = bg@geno, MARGIN = 2, FUN = sd)
}
\seealso{
\code{\link[=chunkedApply]{chunkedApply()}} if \code{X} is a memory-mapped matrix and too large to
hold in memory.
}
